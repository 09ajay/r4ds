---
layout: default
title: Data Visualization
output: bookdown::html_chapter
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

# Visualize Data

> "The simple graph has brought more information to the data analystâ€™s mind than any other device."---John Tukey

Visualization makes data decipherable. Have you ever tried to study a table of raw data? You can examine values one at a time, but you cannot attend to many values at once. The data overloads your attention span, which makes it hard to spot patterns in the data. See this for yourself; can you spot the striking relationship between $X$ and $Y$ in the table below?

```{r data, echo=FALSE}
x <- rep(seq(0.2, 1.8, length = 5), 2) + runif(10, -0.15, 0.15)
X <- c(0.02, x, 1.94)
Y <- sqrt(1 - (X - 1)^2)
Y[1:6] <- -1 * Y[1:6]
Y <- Y - 1
order <- sample(1:10)
knitr::kable(round(data.frame(X = X[order], Y = Y[order]), 2))
```

Raw data is difficult to comprehend, but visualized data is easy to understand. Once you plot your data, you can see the relationships between data points---instantly. For example, the graph below shows the same data as above. Here, the relationship between the points is obvious.

```{r echo=FALSE, dependson=data}
ggplot2::qplot(X, Y) + ggplot2::coord_fixed(ylim = c(-2.5, 2.5), xlim = c(-2.5, 2.5))
```

This chapter will teach you how to visualize your data with R and the `ggplot2` package. R contains several systems for making graphs, but the `ggplot2` system is one of the most beautiful and most versatile. `ggplot2` implements the *grammar of graphics*, a coherent system for describing and building graphs. With `ggplot2`, you can do more faster by learning one system and applying it in many places.

## Outline

In *Section 1*, you will learn how to make scatterplots, the most popular type of data visualization. Along the way, you will learn to add information to your plots with color, size, shape, and facets; and how to change the "type" of your plot with _geoms_ .

*Section 2* shows how to build bar charts. Here you will learn how to plot summaries of your data with _stats_ and how to control the placement of objects with with _positions_. You'll also see how to change the _coordinate system_ of your graph.

*Section 3* draws on examples in the first two sections to teach the _gramar of graphics_, a versatile system for describing---and building---any plot.

*Section 4* describes the best ways to visualize distributions of values.

*Section 5* teaches the best ways to visualize relationships between variables.

*Section 6* shows how to use `ggplot2` to create maps.

*Section 7* concludes the chapter by showing how to customize your plots with labels, legends, and color schemes.

## Prerequisites

To access the data sets and functions that we will use in this chapter, load the `ggplot2` package:

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
```

```{r eval = FALSE}
install.packages("ggplot2")
library(ggplot2)
```

## Scatterplots

> "A picture is not merely worth a thousand words, it is much more likely to be scrutinized than words are to be read."---John Tukey

Do cars with big engines use more fuel than cars with small engines? 

Try to answer the question with a precise hypothesis: What does the relationship between engine size and fuel efficieny look like? Is it positive? Negative? Linear? Nonlinear? Strong? Weak?

You can test your hypothesis with the `mpg` data set in the `ggplot2` package. The data set contains observations collected by the EPA on 38 models of car. Among the variables in `mpg` are `displ`, a car's engine size in litres, and `hwy`, a car's fuel efficiency on the highway in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. 

To learn more about `mpg`, open its help page with the command `?mpg`.

***

*Tip*: If you have trouble loading `mpg`, its help page, or any of the functions in this chapter, you may need to load the `ggplot2` package with the command

```{r eval=FALSE}
library(ggplot2)
```

You will need to reload the package each time you start a new R session.

***

The code below plots the `displ` variable of `mpg` against the `hwy` variable. Open an R session and run the code. Does the graph confirm or refute your hypothesis?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

You can immediately see that there is a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`). In other words, cars with big engines have a worse fuel efficiency. But the graph shows us something else as well. 

One group of points seems to fall outside the linear trend. These cars have a higher mileage than you might expect. Can you tell why? Before we examine these cars, let's review the code that made our graph.

`r bookdown::embed_png("images/visualization-1.png", dpi = 150)`

### Template

Our is almost a template for making plots with `ggplot2`.

```{r eval=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

With `ggplot2`, you begin a plot with the function `ggplot()`. `ggplot()` doesn't create a plot by itself; instead it initializes a new plot that you can add layers to. 

The first argument of `ggplot()` is the data set to use in the graph. So `ggplot(data = mpg)` initializes a graph that will use the `mpg` data set.

You complete your graph by adding one or more layers to `ggplot()`. Here, the function `geom_point()` adds a layer of points to the plot, which creates a scatterplot. `ggplot2` comes with 37 different `geom_` functions that you can use with `ggplot()`. Each function creates a different type of layer, and each function takes a mapping argument.

The mapping argument explains where your points should go. You must always set mapping to a call to `aes()`. The `x` and `y` arguments of `aes()` explain which variables to map to the x and y axes of the graph. `ggplot()` will look for those variables in your data set, `mpg`.

You can use this code as a template to make any graph with `ggplot2`. To make a graph, replace the bracketed sections in the code below with a new data set, a new geom, or a new set of mappings. You can also add functions and arguments to the template that do not appear here. 

```{r eval = FALSE}
ggplot(data = <DATA>) + 
  geom_<GEOM>(mapping = aes(<MAPPINGS>))
```

### Aesthetic Mappings

> "The greatest value of a picture is when it forces us to notice what we never expected to see."---John Tukey

Our plot above revealed a groups of cars that had better than expected mileage. How can you explain these cars? 

Let's hypothesize that the cars are hybrids. One way to test this hypothesis is to look at the `class` value for each car. The `class` variable of the `mpg` data set classifies cars into groups such as compact, midsize, and suv. If the outlying points are hybrids, they should be classified as compact, or perhaps subcompact, cars (keep in mind that this data was collected before hybrid trucks and suvs became popular).

There are two ways to add a third value, like `class`, to a two dimensional scatterplot. You can map the value to a new _aesthetic_ or you can divide the plot into _facets_.

An aesthetic is a visual property of the points in your plot. Aesthetics include things like the size, the shape, or the color of your points. You can display a point (like the one below) in different ways by changing its aesthetic properties.

`r bookdown::embed_png("images/visualization-2.png", dpi = 150)`

You can convey information about your data by mapping the aesthetics in your plot to the variables in your data set. For example, we can map the colors of our points to the `class` variable. Then the color of each point will reveal its class affiliation.

To map an aesthetic to a variable, set the name of the aesthetic to the name of the variable, and do this _in your plot's `aes()` call_:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

`ggplot2` will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable. `ggplot2` will also add a legend that explains which levels correspond to which values.

The colors reveal that many of the unusual points are two seater cars. These cars don't seem like hybrids. In fact, they seem like sports cars---and that's what they are. Sports cars have large engines like suvs and pickup trucks, but small bodies like midsize and compact cars, which improves their gas mileage. In hindsight, these cars were unlikely to be hybrids since they have such large engines.

Color is one of the most popular aesthetics to use in a scatterplot, but we could have mapped `class` to the size aesthetic in the same way. In this case, the exact size of each point reveals its class affiliation. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

Or we could have mapped `class` to the _alpha_ (i.e., transparency) of the points. Now the transparency of each point corresponds with its class affiliation. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

We also could have mapped `class` to the shape of the points.

```{r warning=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

In each case, we set the name of the aesthetic to the variable to display and we do this within the `aes()` function. The syntax highlights a useful insight because we also set `x` and `y` to variables within `aes()`: the x and y locations of a point are also aesthetics, visual properties that you can map to variables to display information about the data. 

Once you set an aesthetic, `ggplot2` takes care of the rest. It selects a pleasing set of values to use for the aesthetic and it constructs a legend that explains the mapping. For x and y aesthetics, `ggplot2` does not create a legend, but it creates an axis line with tick marks and a label. The axis line acts in the same way as a legend; it explains the mapping between locations and values.

Now that you know how to use aesthetics, take a moment to experiment with the `mpg` data set. 

* Attempt to match different types of variables to different types of aesthetics. 
    + Continuous variables in `mpg`: `displ`, `year`, `cyl`, `cty`, `hwy`
    + Discrete variables in `mpg`: `manufacturer`, `model`, `trans`, `drv`, `fl`, `class`
* Attempt to use more than one aesthetic at a time. 
* Attempt to set an aesthetic to something other than a variable name, like `displ < 5`.

See the help page for `geom_point()` (`?geom_point`) to learn which aesthetics are available to use in a scatterplot. See the help page for the `mpg` data set (`?mpg`) to learn which variables are in the data set.

Have you experimented with aesthetics? Great! Here are some things that you may have noticed.

#### Continuous data

A continuous variable can contain an infinite number of values that can be put in order, like numbers or date-times. If your variable is continuous, `ggplot2` will treat it in a special way. `ggplot2` will

* use a gradient of colors from blue to black for the color aesthetic
* display a colorbar in the legend for the color aesthetic
* not use the shape aesthetic

 `ggplot2` will not use the shape aesthetic to display continuous information because the human eye cannot easily interpolate between shapes. Can you tell whether a shape is three-quarters of the way between a triangle and a circle? How about five-eights of the way?

`ggplot2` will treat your variable as continuous if it is a numeric, integer, or a recognizable date-time structure (but not a factor, see `?factor`). 

#### Discrete data

A discrete variable can only contain a finite (or countably infinite) set of values. Character strings and boolean values are examples of discrete data. `ggplot2` will treat your variable as discrete if it is not a numeric, integer, or recognizable date-time structure. 

If your data is discrete, `ggplot2` will:

* use a set of colors that span the hues of the rainbow. The exact colors will depend on how many hues appear in your graph. `ggplot2` selects the colors in a way that ensures that one color does not visually dominate the others.
* use equally spaced values of size and alpha
* display up to six shapes for the shape aesthetic.

If your data requires more than six unique shapes, `ggplot2` will print a warning message and only display the first six shapes. You may have noticed this in the graph above (and below), `ggplot2` did not display the suv values, which were the seventh unique class.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

See _Section 7_ to learn how to pick your own colors, shapes, sizes, etc. for `ggplot2` to use.

#### Multiple aesthetics

You can use more than one aesthetic at a time. `ggplot2` will combine aesthetic legends when possible.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = drv, shape = drv, size = cty))
```

#### Expressions

You can map an aesthetic to more than a variable. You can map an aesthetic to raw data, or an expression.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = 1:234))
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = displ < 5))
```

#### Setting vs. Mapping

You can also manually set aesthetics to specific levels. For example, you can make all of the points in your plot blue.

```{r echo = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

To set an aesthetic manually, call the aesthetic name as an argument of your geom function. Then pass the aesthetic a value that R will recognize, such as 

* the name of a color as a character string
* the size of a point as a cex expansion factor (see `?par`)
* the shape as a point as a number code

R uses the following numeric codes to refer to the following shapes. 

```{r echo=FALSE}
pchShow <-
  function(extras = c("*",".", "o","O","0","+","-","|","%","#"),
           cex = 2, 
           col = "red3", bg = "gold", coltext = "brown", cextext = 1.1,
           main = "")
  {
    nex <- length(extras)
    np  <- 26 + nex
    ipch <- 0:(np-1)
    k <- floor(sqrt(np))
    dd <- c(-1,1)/2
    rx <- dd + range(ix <- ipch %/% k)
    ry <- dd + range(iy <- 3 + (k-1)- ipch %% k)
    pch <- as.list(ipch) # list with integers & strings
    if(nex > 0) pch[26+ 1:nex] <- as.list(extras)
    plot(rx, ry, type = "n", axes  =  FALSE, xlab = "", ylab = "", main = main)
    abline(v = ix, h = iy, col = "lightgray", lty = "dotted")
    for(i in 1:np) {
      pc <- pch[[i]]
      points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex)
      if(cextext > 0)
          text(ix[i] - 0.4, iy[i], pc, col = coltext, cex = cextext)
    }
  }

pchShow()
```

If you try to set an aesthetic from within the mappings argument (i.e. the `aes()` call), you will get an unexpected result, as below.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```

Here, `ggplot2` treats `color = "blue"` as a mapping because it appears in the mapping argument. `ggplot2` assumes that "blue" is a value in the data space. It uses R's recycling rules to pair the single value "blue" with each row of data in `mpg`. Then `ggplot2` creates a mapping from the value "blue" in the data space to the pinkish color that we see in the visual space. `ggplot2` even creates a legend to let you know that the color pink represents the value "blue." The choice of pink is a coincidence; `ggplot2` defaults to pink whenever a single discrete value is mapped to the color aesthetic.

If you experience this type of behavior, remember:

* define an aesthetic _within_ the `aes()` function to map levels of the aesthetic to values of data. You would expect a legend after this operation.
* define an aesthetic _outside of_ the `aes()` function to manually set the aesthetic to a specific level. You would not expect a legend after this operation.

### Facets

Facets provide a second way to add a variables to a two dimensional graph. When you facet a graph, you divide your data into subgroups and then plot a separate graph, or _facet_, for each subgroup. 

For example, we can divide our data set into four subgroups based on the `cyl` variable: 

1. all of the cars that have four cylinder engines
2. all of the cars that have five cylinder engines (there are some)
3. all of the cars that have six cylinder engines, and
4. all of the cars that have eight cylinder engines

Or we could divide our data into three groups based on the `drv` variable:

1. all of the cars with four wheel drive (4)
2. all of the cars with front wheel drive (f)
3. all of the cars with rear wheel drive (r)

We could even divide our data into subgroups based on the combination of two variables:

1. all of the cars with four wheel drive (4) and 4 cylinders
2. all of the cars with four wheel drive (4) and 5 cylinders
3. all of the cars with four wheel drive (4) and 6 cylinders
4. all of the cars with four wheel drive (4) and 8 cylinders
5. all of the cars with front wheel drive (f) and 4 cylinders
6. all of the cars with front wheel drive (f) and 5 cylinders
7. all of the cars with front wheel drive (f) and 6 cylinders
8. all of the cars with front wheel drive (f) and 8 cylinders
9. all of the cars with rear wheel drive (r) and 4 cylinders
10. all of the cars with rear wheel drive (r) and 5 cylinders
11. all of the cars with rear wheel drive (r) and 6 cylinders
12. all of the cars with rear wheel drive (r) and 8 cylinders

#### `facet_grid()`

The graphs below show what a faceted graph looks like. They also show how you can build a faceted graph with `facet_grid()`. I'm not going to tell you how `facet_grid()` works---well at least not yet. That would be too easy. Instead, I would like you to try to induce the syntax of `facet_grid()` from the code below. Consider:

* Which variables determine how the graph is split into rows?
* Which variables determine how the graph is split into columns?
* What parts of the syntax always stay the same? 
* And what does the `.` do?

Make an honest effort at answering these questions, and then read on past the graphs.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ cyl)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```

Ready for the answers?

To facet your graph, add `facet_grid()` to your code. The first argument of `facet_grid()` is always a formula, two variable names separated by a `~`. 

`facet_grid()` will use the first variable in the formula to split the graph into rows. Each row will contain data points that have the same value of the variable. 

`facet_grid()` will use the second variable in the formula to split the graph into columns. Each column will contain data points that have the same value of the second variable.

This syntax mirrors the rows first, columns second convention of R. 

If you prefer to facet your plot on only one dimension, add a `.` to your formula as a place holder. If you place a `.` before the `~`, `facet_grid()` will not facet on the rows dimension. If you place a `.` after the `~`, `facet_grid()` will not facet on the columns dimension.

Facets let you quickly compare subgroups by glancing down rows and across columns. Each facet will use the same limits on the x and y axes, but you can change this behavior across rows or columns by adding a scales argument. Set scales to one of 

* `"free_y"` - to let y limits vary accross rows
* `"free_x"` - to let x limits vary accross columns
* `"free"` - to let both x and y limits vary

For example, the code below lets the limits of the x axes vary across columns.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ cyl, scales = "free_x")
```


#### `facet_wrap()`

What if you want to facet on a variable that has too many values to display nicely?

For example, if we facet on `class`, `ggplot2` must display narrow subplots to fit each subplot into the same column. This makes it diffcult to compare x values with precision.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ class)
```

`facet_wrap()` provides a more pleasant way to facet a plot across many values. It wraps the subplots into a multi-row, roughly square result.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(~ class)
```

The results of `facet_wrap()` can be easier to study than the results of `facet_grid()`. However, `facet_wrap()` can only facet by one variable at a time.

### Geoms

You can add new data to your scatterplot with aesthetics and facets, but how can you summarize the data that is already there, for example with a trend line?

You can add summary information to your scatterplot with a geom. To understand geoms, ask yourself: how are these two plots similar? 

```{r echo = FALSE, message = FALSE, fig.show='hold', fig.width=4, fig.height=4}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Both plots contain the same: 

* x variable
* y variable
* underlying data set

But the plots are not identical. Each uses a different _geom_, or geometrical object, to represent the data. The first plot uses a set of points to represent the data. The second plot uses a single, smoothed line. 

To create the second plot, replace `geom_point()` in our template code... 

```{r eval=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

...with `geom_smooth()`,

```{r eval=FALSE, message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

`ggplot2` comes with 37 `geom_` functions that you can use to to visualize your data. Each function will represent the data with a different type of geom, like a bar, a line, a boxplot, a histogram, etc. You select the type of plot you wish to make by calling the geom_ function that draws the geom you have in mind.

Each `geom_` function takes a `mapping` argument. However, the aesthetics that you pass to the argument will change from geom to geom. For example, you can set the shape of points, but it would not make sense to set the shape of a line. 

To see which aesthetics your geom uses, visit its help page. To see a list of all available geoms, open the `ggplot2` package help page with `help(package = ggplot2)`.

#### Group aesthetic

The _group_ aesthetic is a useful way to apply a monolithic geom, like a smooth line, to multiple subgroups. 

By default, `geom_smooth()` draws a single smoothed line for the entire data set. To draw a separate line for each group of points, set the group aesthetic to a grouping variable or expression.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, group = displ < 5))
```

`ggplot2` will automatically infer a group aesthetic when you map an aesthetic of a monolithic geom to a discrete variable. Below `ggplot2` infers a group aesthetic from the `linetype = drv` aesthetic. It is useful to combine group aesthetics with secondary aesthetics because `ggplot2` cannot build a legend for a group aesthetic.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

#### Multiple geoms

You can add a smooth line to your raw data by adding `geom_smooth()` to your original plot call. 

```{r, message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping= aes(x = displ, y = hwy))
```

This system lets you build sophisticated graphs geom by geom. You can add as many geoms as you like to a single plot call. `ggplot2` will place each new geom on top of the preceeding geom.

#### Global and local mappings

You can create a set of global mappings that apply to all geoms  by passing a mapping argument to `ggplot()`. For example, we can eliminate the duplication of `mapping = aes(x = displ, y = hwy)` in our previous code by using global mappings:

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

You can also combine global mappings with local mappings to differentiate geoms.

* Mappings that appear in `ggplot()` will be applied to each geom.
* Mappings that appear in a geom function will be applied to that geom only.
* If a local mapping conflicts with a global mapping, `ggplot2` will use the local mapping for that geom only.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

The smooth line above is a single line with a single color. This does not occur if you add the color aesthetic to the global mappings. Smooth will draw a different colored line for each class of cars.

```{r, message = FALSE, warning = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(aes(y = cty))
```

#### Global and local data sets

You can use the same system to specify individual data sets for each layer.

```{r, eval = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

is analagous to 

```{r, eval = FALSE}
ggplot(mapping = aes(x = displ, y = hwy)) + 
  geom_point(data = mpg) + 
  geom_smooth(data = mpg)
```

To apply the smooth line to a subset of your data, pass it its own data argument, here the subset of cars that have eight cylinders.

```{r, message = FALSE, warning = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(data = subset(mpg, cyl == 8))
```

## Bar Charts

A bar chart is a graph that uses the bar geom. Bar charts are the most commonly used type of plot after scatterplots.

The chart below displays the total number of diamonds in the `diamonds` data set, grouped by `cut`. The `diamonds` data set comes in `ggplot2` and contains information about 53940 diamonds, including the `price`, `carat`, `color`, `clarity`, and `cut` of each diamond.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

The graph shows that more diamonds are available with high quality cuts than low quality cuts. 

A bar has different visual properties than a point, which can create some surprises. For example, how would you create this simple chart? If you have an R session open, give it a try.

```{r echo=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

It may be tempting to call the color aesthetic, but for bars and other large geoms the color aesthetic controls the _outline_ of the geom, e.g.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, color = cut))
```

The effect is interesting, sort of psychedelic, but not what we had in mind.

To control the interior fill of a bar, polygon, histogram, boxplot, or other geom with mass, you must call the _fill_ aesthetic.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

If you map the fill aesthetic to a third variable, like `clarity`, you get a stacked bar chart.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

Bar charts are interesting because they reveal something subtle about common types of plots.

### Stats

Consider our basic bar chart. 

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

On the x axis it displays `cut`, a variable in the `diamonds` data set. On the y axis, it displays count. But count is not a variable in the diamonds data set:

```{r}
head(diamonds)
```

Nor did we tell `ggplot2` in our code where to find count values.

```{r eval = FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

Where does count come from?

Some graphs, like scatterplots, plot the raw values of your data set. Other graphs, like bar charts and smooth lines, do not plot raw values at all. These graphs apply an algorithm to your data and then plot the results of the algorithm. Consider how many graphs do this.

* **bar charts** and **histograms** bin the raw data and then plot bin counts
* **smooth lines** apply a model to the raw data and then plot the model line
* **boxplots** calculate the quartiles of the raw data and then plot the quartiles as a box.
* and so on.

`ggplot2` calls the algorithm that a graph uses to transform raw data a _stat_, which is short for statistical transformation.
 
Each geom in `ggplot2` is designed to use a default stat when it creates a graph (if a geom plots the raw data it uses the "identity" stat, i.e. an identity transformation). In many cases, it does not make sense to change a geom's default stat. In other cases, you can change or fine tune the stat to make new graphs. 

***

*Tip*: To learn which stat a geom uses, visit the geom's help page, e.g. `?geom_bar`. To learn more about a stat, visit the stat's help page, e.g. `?stat_bin`.

***

#### Change a stat

You can map the heights of bars in a bar chart to data values---not counts---by changing the stat of the bar chart. This works best if your data set contains one observation per bar, e.g.

```{r}
demo <- data.frame(
  a = c("bar_1","bar_2","bar_3"),
  b = c(20, 30, 40)
)
```

By default, `geom_bar()` uses the bin stat, which creates a count for each bar.

```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = a))
```

To change the stat of a geom, set its `stat` argument to the name of a stat. You may need to supply or remove mappings to accomodate the new stat. 

```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = a, y = b), stat = "identity")
```

To find a list of available stats, run `help(package = "ggplot2")`. Each stat is listed as a function that begins with `stat_`. Set a geom's stat argument to the part of the function name that follows the underscore, surrounded in quotes, as above. 

Use consideration when you change a stat. Many combinations of geoms and stats create incompatible results. 

#### Set parameters

Many stats use _parameters_ arguments that fine tune the statistical transformation. For example, the bin stat takes the parameter `width`, which controls the width of the bars in a bar chart. 

To set a parameter of a stat, pass the parameter as an argument to the geom function.

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut), width = 1)
```

To learn which parameters are used by a stat, visit the stat's help page, e.g. `?stat_bin`.

#### Use data from a stat

Many stats in `ggplot2` create more data than they display. For example, the `?stat_bin` help page explains that the `stat_bin()` transformation creates four new variables: `count`, `density`, `ncount`, and `ndensity`. `geom_bar()` uses only one of these variables. It maps the `count` variable to the y axis of your plot. 

You can use any of the variables created by a stat in an aesthetic mapping. To use a variable created by a stat, surround its name with a pair of dots, `..`.

```{r message = FALSE, fig.show='hold', fig.width=4, fig.height=4}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = carat))

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = carat, y = ..density..))
```

Note that to do this, you will need to

1. Determine which stat your geom uses
2. Determine which variables the stat creates from its help page
3. Surround the variable name with `..`

### Position

At the beginning of this section, you learned how to use the fill aesthetic to make a stacked bar chart. 

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

But what if you don't want a stacked bar chart? What if you want the chart below? Could you make it?

```{r echo = FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

This chart displays the same 40 color coded bars as the stacked bar chart above. Each bar represents a combination of `cut` and `clarity`. 

However, the position of the bars within the two charts is different. In the stacked bar chart, `ggplot2` stacked the bars on top of each other if they had the same cut. In the second plot, `ggplot2` placed the bars beside each other if they had the same cut.

You can control this behavior by adding a _position adjustment_ to your call. A position adjustment tells `ggplot2` what to do when two or more objects overlap.

To set a position adjustment, set the `position` argument of your geom function to one of `"identity"`, `"stack"`, `"dodge"`, `"fill"`, or `"jitter"`.

#### Position = "identity"

For many geoms, the default position value is "identity". When `position = "identity"`, `ggplot2` will place each object exactly where it falls in the context of the graph. 

This would make little sense for our bar chart. Each bar would start at `y = 0` and would appear directly above the `cut` value that it describes. Since there are seven bars for each value of `cut`, many bars would overlap. The plot will look suspiciously like a stacked bar chart, but the stacked heights will be inaccurate, as each bar actually extends to `y = 0`. Some bars would not appear at all because they would be completely overlapped by other bars.

To see how such a graph would appear, set `position = "identity"`.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "identity") +
  ggtitle('Position = "identity"')
```

#### Position = "stack"

To avoid confusion, `ggplot2` uses a default "stack" position adjustment for bar charts. When `position = "stack"` `ggplot2` places overlapping objects directly _above_ one another.

Here each bar begins exactly where the bar below it ends.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "stack") +
  ggtitle('Position = "stack"')
```

#### Position = "dodge"

When `position = "dodge"`, `ggplot2` places overlapping objects directly _beside_ one another. This is how I created the graph at the start of the section.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge") +
  ggtitle('Position = "dodge"')
```

#### Position = "fill"

When `position = "fill"`, `ggplot2` uses all of the available space to display overlapping objects. Within that space, `ggplot2` scales each object in proportion to the other objects. `position = "fill"` is the most unusual of the position adjustments, but it creates an easy way to compare relative frequencies across groups.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill") +
  ggtitle('Position = "fill"')
```


#### Position = "jitter"

The last type of position doesn't make sense for bar charts, but it is very useful for scatterplots. Recall our first scatterplot.

```{r echo = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

Why does the plot appear to display only 126 points? There are 234 observations in the data set. Also, why do the points appear to be arranged on a grid?

The points appear in a grid because the `hwy` and `displ` measurements were rounded to the nearest integer and tenths values. As a result, many points overlap each other because they've been rounded to the same values of `hwy` and `displ`. This also explains why our graph appears to contain only 126 points. 108 points are hidden on top of other points located at the same value.

This arrangement can cause problems because it makes it hard to see where the mass of the data is. Is there one special combination of `hwy` and `displ` that contains 109 values? Or are the data points more or less equally spread throughout the graph?

You can avoid this overplotting problem by setting the position adjustment to "jitter".  `position = "jitter"` adds a small amount of random noise to each point, as we see above. This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

But isn't this, you know, bad? It *is* true that jittering your data will make it less accurate at the local level, but jittering may make your data _more_ accurate at the global level. By jittering your data, you can see where the mass of your data falls on an overplotted grid. Occasionally, jittering will reveal a pattern that was hidden within the grid.

`ggplot2` recognizes `position = "jitter"` as shorthand for `position = position_jitter()`. This is true for the other values of position as well: 

* `position = "identity"` is shorthand for `position = position_identity()`
* `position = "stack"` is shorthand for `position = position_stack()`
* `position = "dodge"` is shorthand for `position = position_dodge()`
* `position = "fill"` is shorthand for `position = position_fill()`

You can use the explanded syntax to specify details of the position process. You can also use the expanded syntax to open a help page for each position process (which you will need to do if you wish to learn more).

```{r eval=FALSE}
?position_jitter
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), 
    position = position_jitter(width = 0.03, height = 0.3))
```

### Coordinate systems

You can make your bar charts even more versatile by changing the coordinate system of your plot. For example, you could flip the x and y axes of your plot, or you could plot your bar chart on polar coordinates to make a coxcomb plot or a polar clock chart.

```{r echo = FALSE, message = FALSE, fig.show='hold', fig.width=3, fig.height=4}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut)) + 
  coord_flip()
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut), width = 1) + 
  coord_polar()
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut), width = 1) + 
  coord_polar(theta = "y")
```

To change the coordinate system of your plot, add a `coordinate_` function to your plot call. `ggplot2` comes with seven coordinate functions that each implement a different coordinate system.

#### Cartesian coordinates

`coord_cartesian()` generates a cartesian coordinate system for your plot. `ggplot2` adds a call to `coord_cartesian()` to your plot by default, but you can also manually add this call. Why would you want to do this?

You can set the `xlim` and `ylim` arguments of `coord_cartesian()` to zoom in on a region of your plot. Set each argument to a vector of length 2. `ggplot2` will use the first value as the minimum value on the x or y axis. It will use the second value as the maximum value.

Zooming is not very useful in our bar graph, but it can help us study the sports cars in our scatterplot.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
  coord_cartesian(xlim = c(4.5, 7.5), ylim = c(20, 30))
```

You can use the same arguments to zoom with any of the coordinate functions in `ggplot2`.

***

*Tip*: You can also zoom by adding `xlim()` and/or `ylim()` to your plot call. 

```{r eval = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
  xlim(4.5, 7.5) + 
  ylim(20, 30)
```

However, `xlim()` and `ylim()` do not provide a true zoom. Instead, they plot the subset of data that appears within the limits. This may change the appearance of elements that rely on unseen data points, such as a smooth line.

***

#### Fixed coordinates

`coord_fixed()` also generates a cartesian coordinate system for your plot. However, you can used `coord_fixed()` to set the visual ratio between units on the x axis and units on the y axis. To do this, set the `ratio` argument to the desired ratio in length between y units and x units, e.g.

$$\text{ratio} = \frac{\text{length of one Y unit}}{\text{length of one X unit}}$$

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = factor(1), fill = cut)) + 
  coord_fixed(ratio = 0.5)
```

`coord_equal()` does the same thing as `coord_fixed()`.

#### Flipped coordinates

Add `coord_flip()` to your plot to switch the x and y axes.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut)) + 
  coord_flip()
```

#### Map coordinates

Add `coord_map()` or `coord_quickmap()` to plot map data on a cartographic projection. See _Section 6_ for more details.

#### Polar coordinates

Add `coord_polar()` to your plot to plot your data in polar coordinates. 

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut), width = 1) + 
  coord_polar()
```

By default, `ggplot2` will map your y variable to $r$ and your x variable to $\theta$. When applied to a bar chart, this creates a coxcomb plot. 

Reverse this behavior with the argument `theta = "y"`. When applied to a bar chart, this creates a polar clock chart.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut), width = 1) + 
  coord_polar(theta = "y")
```

You can also use the `start` argument to control where in the plot your data starts, from 0 to 12 (o'clock), and the `direction` argument to control the orientation of the plot (1 for clockwise, -1 for anti-clockwise).

***

*Tip*: `ggplot2` does not come with a pie chart geom, but you can make a pie chart by plotting a stacked bar chart in polar coordinates. To do this, ensure that:

* your x axis only has one value, e.g. `x = factor(1)`
* `width = 1`
* `theta = "y"`

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = factor(1), fill = cut), width = 1) + 
  coord_polar(theta = "y")
```

***

#### Transformed coordinates

Add `coord_trans()` to plot your data on cartesian coordinates that have been transformed in some way. To use `coord_trans()`, set the `xtrans` and/or `ytrans` argument to the name of a function that you would like to apply to the x and/or y values.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  coord_trans(xtrans = "log", ytran = "log")
```






## The Grammar of Graphics

> "Wax on. Wax off."---Mr. Miyagi. *The Karate Kid* (1984)

### Layers

## Visualizing Distributions
### Discrete distributions
#### Bar Charts
### Continuous distributions
#### Histograms
#### Dotplots
#### Freqpoly
#### Density
#### Boxplots
### Bivariate Distributions
#### bin2d
#### hex
#### density2d
#### rug

## Visualizing Relationships
### Discrete x, discrete y
#### Jitter
### Discrete x, continuous y
#### Bar Charts
#### Boxplots
#### Dotplots
#### Violin plots
#### crossbar
#### errorbar
#### linerange
#### point range
### Continuous x, continuous y
#### Points
#### Text
#### Jitter
#### Smooth
#### Quantile
### Functions
#### line
#### area
#### step
### Discrete x, discrete y, continuous z
#### raster
#### tile
### Continuous x, continuous y, continuous z
#### contour
### Advice for Big Data

## Maps

## Customizing plots
### Titles
### Guides
### Scales
#### Color
#### Size
#### Shape
### Themes


