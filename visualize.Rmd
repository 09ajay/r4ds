---
layout: default
title: Data Visualization
output: bookdown::html_chapter
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE)
```

# Visualize Data

> "The simple graph has brought more information to the data analystâ€™s mind than any other device."---John Tukey

Visualization makes data decipherable. Have you ever tried to study a table of raw data? Raw data is difficult to comprehend. You can examine values one at a time, but you cannot attend to many values at once. The data overloads your attention span, which makes it hard to spot patterns in the data. See this for yourself; can you spot the striking relationship between $X$ and $Y$ in the table below?

```{r echo=FALSE}
X <- rep(seq(0.1, 1.9, length = 6), 2) + runif(12, -0.1, 0.1)
Y <- sqrt(1 - (X - 1)^2)
Y[1:6] <- -1 * Y[1:6]
Y <- Y - 1
order <- sample(1:10)
knitr::kable(round(data.frame(X = X[order], Y = Y[order]), 2))
```

In contrast, visualized data is easy to understand. Once you plot your data, you can see the relationships between data points---instantly. For example, the graph below shows the same data as above. Here, the relationship between the points is obvious.

```{r echo=FALSE}
ggplot2::qplot(X, Y) + ggplot2::coord_fixed(ylim = c(-2.5, 2.5), xlim = c(-2.5, 2.5))
```

This chapter will teach you how to visualize your data with R and the `ggplot2` package. R contains several systems for making graphs, but the `ggplot2` system is one of the most beautiful and most versatile. `ggplot2` implements the *grammar of graphics*, a coherent system for describing and building graphs. With `ggplot2`, you can do more faster by learning one system and applying it in many places.

## Outline

In *Section 1*, you will learn how to make scatterplots, the most popular type of data visualization. Along the way, you will learn to add information to your plots with color, size, shape, and facets; and how to change the "type" of your plot with _geoms_ .

*Section 2* shows how to build bar charts. Here you will learn how to plot summaries of your data with _stats_ and how to control the placement of objects with with _positions_. You'll also see how to change the _coordinate system_ of your graph.

*Section 3* draws on examples in the first two sections to teach the _gramar of graphics_, a versatile system for describing---and building---any plot.

*Section 4* describes the best practices and functions for visualizing distributions of values.

*Section 5* teaches the best practices and functions for visualizing relationships between variables.

*Section 6* shows how to use `ggplot2` to create maps.

*Section 7* concludes the chapter by showing how to customize your plots with labels, legends, and color schemes.

## Prerequisites

To access the data sets and functions that we will use in this chapter, load the `ggplot2` package:

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
```

```{r eval = FALSE}
install.packages("ggplot2")
library(ggplot2)
```

## Scatterplots

> "A picture is not merely worth a thousand words, it is much more likely to be scrutinized than words are to be read."---John Tukey

Do cars with big engines use more fuel than cars with small engines? 

Try to answer the question with a precise hypothesis: What does the relationship between engine size and fuel efficieny look like? Is it positive? Negative? Linear? Nonlinear? Strong? Weak?

You can test your hypothesis with the `mpg` data set in the `ggplot2` package. The data set contains observations collected by the EPA on 38 models of car. Among the variables in `mpg` are `displ`, a car's engine size in litres, and `hwy`, a car's fuel efficiency on the highway in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. 

To learn more about `mpg`, open its help page with the command `?mpg`.

***

*Tip*: If you have trouble loading `mpg`, its help page, or any of the functions in this chapter, you may need to load the `ggplot2` library with the command

```{r eval=FALSE}
library(ggplot2)
```

You will need to reload the library each time you start a new R session.

***

The code below plots the `displ` variable of `mpg` against the `hwy` variable. Open an R session and run the code. Does the graph confirm or refute your hypothesis?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

You can immediately see that there is a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`). In other words, cars with big engines have a worse fuel efficiency. But the graph shows us something else as well. 

One group of points seems to fall outside the linear trend. These cars have a higher mileage than you might expect. Can you tell why? Before we examine this phenomenon, let's review the code that made our graph.

`r bookdown::embed_png("images/visualization-1.png", dpi = 150)`

### Template

Our code is almost a template for making plots with `ggplot2`.

```{r eval=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

With `ggplot2`, you begin every plot with the function `ggplot()`. `ggplot()` doesn't create a plot by itself; instead it initializes a new plot that you can add layers to. 

The first argument of `ggplot()` is the data set that you would like to use in your graph. So `ggplot(mpg)` initializes a graph that will use the `mpg` data set.

To complete a graph, you add one or more layers to `ggplot()`. The function `geom_point()` adds a layer of points to the plot, which creates a scatterplot. The mapping argument explains where those points should go. You must always set mapping to a call to `aes()`. The `x` and `y` arguments of `aes()` explain which variables to map to the x and y axes of the graph.

You can use this code as a template to make any graph with `ggplot2`. To make a graph, replace the bracketed sections in the code below with a new data set, a new geom, or a new set of mappings. You can also add functions and arguments to the template that do not appear here. 

```{r eval = FALSE}
ggplot(data = <DATA>) + 
  geom_<GEOM>(mapping = aes(<MAPPINGS>))
```

### Aesthetic Mappings

> "The greatest value of a picture is when it forces us to notice what we never expected to see."---John Tukey

Our plot above revealed a groups of cars that had better than expected mileage. How can you explain these cars? 

Let's hypothesize that the cars are hybrids. One way to test this hypothesis is to look at the `class` value for each car. The `class` variable of the `mpg` data set classifies cars into groups such as compact, midsize, and suv. If the outlying points are hybrids, they should be classified as compact, or perhaps subcompact, cars (keep in mind that this data was collected before hybrid trucks and suvs became popular).

There are two ways to add a third value, like `class`, to a two dimensional scatterplot. You can map the value to a new _aesthetic_ or you can divide the plot into _facets_.

An aesthetic is a visual property of the points in your plot. Aesthetics include things like the size, the shape, or the color of your points. 

`r bookdown::embed_png("images/visualization-2.png", dpi = 150)`

You can convey information by mapping the aesthetics in your plot to the variables in your data set. For example, we can map the colors of the points to the `class` variable. Then the color of each point will reveal its class affiliation.

To map an aesthetic to a variable, set the name of the aesthetic to the name of the variable, and do this _in your plot's `aes()` call_:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

`ggplot2` will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable. `ggplot2` will also add a legend that explains which levels correspond to which values.

You can now see that most of the unusual points are two seater cars. This doesn't sound like a hybrid. In fact, it sounds like a sports car---and that's what the points are. Sports cars have the same size engines as suvs and pickup trucks. However, sports cars have much smaller bodies than suvs and pickup trucks, which improves their gas mileage. In hindsight, these cars were unlikely to be hybrids since they have such large engines.

Color is one of the most popular aesthetics to use in a scatterplot, but we could have mapped the size aesthetic to `class` in the same way. In this case, the exact size of the point reveals its class affiliation. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

Or we could have mapped the _alpha_ of the points to the `class` variable. The alpha is the transparency of the points. Now the transparency of each point corresponds with its class affiliation. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

We also could have mapped the shape of the points to the `class` variable.

```{r warning=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

In each case above, we set the name of the aesthetic to the variable to display and we do this within the `aes()` function. The syntax highlights a useful insight since we also set `x` and `y` to variables within `aes()`: the x location and the y location of a point are also aesthetics, visual properties that we can map to variables. 

Once you set an aesthetic, `ggplot2` takes care of the rest. It selects a pleasing set of values to use for the aesthetic and it constructs a legend that explains the mapping. For x and y aesthetics, `ggplot2` does not create a legend, but it creates an axis line with tick marks and a label. The axis line acts in the same way as a legend; it explains the mapping between locations and values.

Now that you know how to use aesthetics, take a moment to experiment with the `mpg` data set. 

* Attempt to match different types of variables to different types of aesthetics. 
* Attempt to use more than one aesthetic at a time. 

See the help page for `geom_point()` (`?geom_point`) to learn which aesthetics are available to use in a scatterplot. See the help page for the `mpg` data set (`?mpg`) to learn which variables are in the data set.

Have you experimented with aesthetics? Great! Here are some things that you may have noticed.

#### Continuous data

A continuous variable can contain an infinite number of values that can be put in order, like numbers or date times. If your variable is continuous, `ggplot2` will treat it differently than a discrete variable. `ggplot2` will

* use a gradient of colors from blue to black for the color aesthetic.
* display a colorbar in the legend for the color aesthetic.
* not use the shape aesthetic.

 `ggplot2` will not use the shape aesthetic to display continuous information. Why? Because the human eye cannot easily interpolate between shapes. Can you tell whether a shape is three quarters of the way between a triangle and a circle? how about five eights of the way?

`ggplot2` will treat your variable as continuous if it is a numeric, integer, or a recognizable date time structure (but not a factor, see `?factor`). 

#### Discrete data

A discrete variable can takes a finite (or countably infinite) set of values. Character strings and boolean values are examples of discrete data. `ggplot2` will treat your variable as discrete if it is not a numeric, integer, or recognizable date time structure. 

If your data is discrete, `ggplot2` will:

* `ggplot2` will use a set of colors that span the hues of the rainbow. The exact colors will depend on how many hues appear in your graph. `ggplot2` selects the colors in a way that ensures that one color does not visually dominate the others.
* use equally spaced values of size and alpha
* display up to six shapes for the shape aesthetic.

If your data requires more than six unique shapes, `ggplot2` will print an error message and only display the first six shapes. You may have noticed this in the graph above (and below), `ggplot2` did not display the suv values, which were the seventh unique class.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

See _Section 7_ to learn how to pick your own colors, shapes, sizes, etc. for `ggplot2` to use.

#### Multiple aesthetics

You can use more than one aesthetic at a time. `ggplot2` will combine aesthetic legeneds where possible.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = drv, shape = drv, size = cty))
```

#### Expressions

You can map an aesthetic to more than a variable. You can map an aesthetic to raw data, or an expression.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = 1:234))
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, 
    color = displ < 5))
```

### Facets

Facets provide a second way to add a variables to a two dimensional graph. When you facet a graph, you divide your data into subgroups and then plot a separate graph, or _facet_, for each subgroup. 

For example, we can divide our data set into four subgroups based on the `cyl` variable: 

1. all of the cars that have four cylinder engines
2. all of the cars that have five cylinder engines (there are some)
3. all of the cars that have six cylinder engines, and
4. all of the cars that have eight cylinder engines

Or we could divide our data into three groups based on the `drv` variable:

1. all of the cars with four wheel drive (4)
2. all of the cars with front wheel drive (f)
3. all of the cars with rear wheel drive (r)

We could even divide our data into subgroups based on the combination of two variables:

1. all of the cars with four wheel drive (4) and 4 cylinders
2. all of the cars with four wheel drive (4) and 5 cylinders
3. all of the cars with four wheel drive (4) and 6 cylinders
4. all of the cars with four wheel drive (4) and 8 cylinders
5. all of the cars with front wheel drive (f) and 4 cylinders
6. all of the cars with front wheel drive (f) and 5 cylinders
7. all of the cars with front wheel drive (f) and 6 cylinders
8. all of the cars with front wheel drive (f) and 8 cylinders
9. all of the cars with rear wheel drive (r) and 4 cylinders
10. all of the cars with rear wheel drive (r) and 5 cylinders
11. all of the cars with rear wheel drive (r) and 6 cylinders
12. all of the cars with rear wheel drive (r) and 8 cylinders

#### `facet_grid()`

The graphs below show what a faceted graph looks like. They also show how you can build a faceted graph with `facet_grid()`. I'm not going to tell you how facet grid works---well at least not yet---because that would be too easy. Instead, I would like you to try to induce the syntax of `facet_grid()` from the code below. 

* What variables determines the graph is split into rows?
* What variables determines the graph is split into columns?
* What parts of the syntax always stay the same? 
* And what does the `.` do?

Make an honest effort at answering these questions, and then read on past the graphs.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ cyl)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)
```

Ready for the answers?

To facet your graph, add `facet_grid()` to your code. The first argument of `facet_grid()` is always a formula, two variable names separated by a `~`. 

`facet_grid()` will use the first variable in the formula to split the graph into rows. Each row will contain data points that have the same value of the variable. 

`facet_grid()` will use the second variable in the formula to split the graph into columns. Each column will contain data points that have the same value of the second variable.

This syntax mirrors the rows first, columns second convention of R. 

If you prefer to facet your plot on only one dimension, add a `.` to your formula as a place holder. If you place a `.` before the `~`, `facet_grid()` will not facet on the rows dimension. If you place a `.` after the `~`, `facet_grid()` will not facet on the columns dimension.

Facets let you quickly compare subgroups by glancing down rows and across columns. Each facet will use the same x and y limits, but you can change this behavior across rows or columns by adding a scales argument. Set scales to one of 

* `"free_y"` - to let y limits vary accross rows
* `"free_x"` - to let x limits vary accross columns
* `"free"` - to let both x and y limits vary

For example, the code below lets x limits vary across columns.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ cyl, scales = "free_x")
```


#### `facet_wrap()`

`facet_wrap()` provides a pleasant way to facet a plot across a single variable with many values. The easiest way to understand `facet_wrap()` is to compare the output of `facet_grid()` and `facet_wrap()`.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ class)
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(~ class)
```

`facet_wrap()` wraps the facets into a multi-row, roughly square result. if your facetting variable has many values, the results of `facet_wrap()` will be easier to study than the results of `facet_grid()`. However, `facet_wrap()` can only facet by one variable at a time.

### Geoms

You can add summary information to your scatterplot with a geom. To understand geoms, ask yourself: how are these two plots similar? 

```{r echo = FALSE, message = FALSE, fig.show='hold', fig.width=4, fig.height=4}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Both plots contain the same: 

* x variable
* y variable
* underlying data set

But the plots are not identical. Each uses a different _geom_, or geometrical object, to represent the data. The first plot uses a set of points to represent the data. The second plot uses a single, smoothed line. 

To create the second plot, replace `geom_point()` in our template code... 

```{r eval=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

...with `geom_smooth()`,

```{r eval=FALSE, message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

`ggplot2` comes with 37 `geom_` functions that you can use to to visualize your data. Each function will represent the data with a different type of geom, like a bar, a line, a boxplot, a histogram, etc. You select the type of plot you wish to make by calling the geom_function that draws the geom you have in mind.

Each `geom_` function takes a `mapping` argument. However, the aesthetics that you pass to the argument will change from geom to geom. For example, you can set the shape of points, but it would not make sense to set the shape of a line. 

To see which aesthetics your geom uses, visit its help page. To see a list of all available geoms, open the `ggplot2` package help page with `help(package = ggplot2)`.

#### Group aesthetic

The _group_ aesthetic is a useful way to apply a monolithic geom, like a smooth, to multiple subgroups. 

By default, `geom_smooth()` draws a single smoothed line for the entire data set. To draw a separate line for each group of points, set the group aesthetic to a grouping variable or expression.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, group = displ < 5))
```

`ggplot2` will automatically infer a group aesthetic when you map an aesthetic of a monolithic geom to a discrete variable. Below `ggplot2` infers a group aesthetic from the `linetype = drv` aesthetic. It is useful to combine group aesthetics with secondary aesthetics because `ggplot2` cannot build a legend for a group aesthetic.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

#### Multiple geoms

How can you use a geom to add summary information to your scatterplot? 

You can adde multiple geoms to the same plot by adding multiple `geom_` functions to the plot call. For example, you can add the smooth geom to your existing scatterplot.

```{r, message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping= aes(x = displ, y = hwy))
```

`ggplot2` will place each new geom on top of the preceeding geom. This system lets you build sophisticated graphs geom by geom.

#### Global and local mappings

Our new code calls `mapping = aes(x = displ, y = hwy)` twice. This is unwise because repetition increases the chance of a typo and makes your code harder to read and write. 

To avoid repetition, pass the set of repeated mappings to `ggplot()`. `ggplot2` will treat these mappings as global mappings and apply them to each geom in your graph. You can then remove the mapping arguments in the individual layers.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

You can also combine global mappings with local mappings to differentiate geoms.

* Mappings that appear in `ggplot()` will be applied to each geom.
* Mappings that appear in a geom function will be applied to that geom only.
* If a local mapping conflicts with a global mapping, `ggplot2` will use the local mapping for that geom only.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

The smooth line above is a single line with a single color. This does not occur if you add the color aesthetic to the global mappings. Smooth will draw a different colored line for each class of cars.

```{r, message = FALSE, warning = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = class)) + 
  geom_point() + 
  geom_smooth()
```

#### Global and local data sets

You can use the same system to specify individual data sets for each layer.

```{r, eval = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

is analagous to 

```{r, eval = FALSE}
ggplot(mapping = aes(x = displ, y = hwy)) + 
  geom_point(data = mpg) + 
  geom_smooth(data = mpg)
```

To apply the smooth line to a subset of the data, pass it its own data argument, here the subset of eight cylinder cars.

```{r, message = FALSE, warning = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(data = subset(mpg, cyl == 8))
```

## Bar Charts

A bar chart is a graph that uses the bar geom. Bar charts are the most commonly used type of plot after scatterplots.

The chart below displays the total number of diamonds in the `diamonds` data set, grouped by `cut`. The `diamonds` data set comes in `ggplot2` and contains information about 53940 diamonds, including the `price`, `carat`, `color`, `clarity`, and `cut` of each diamond.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

The graph shows that more diamonds are available with high quality cuts than low quality cuts. 

A bar has different visual properties than a point, which can create some surprises. For example, how would you create this simple chart? If you have an R session open, give it a try.

```{r echo=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

It may be tempting to call the color aesthetic, but for bars and similar geoms the color aesthetic controls the _outline_ of the geom, e.g.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, color = cut))
```

What an ...interesting effect. Sort of psychedelic! But not what we had in mind.

To control the interior fill of a bar, polygon, histogram, boxplot, or other geom with mass, you must call the _fill_ aesthetic.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

If you map the fill aesthetic to a third variable, like `clarity`, you get a stacked bar chart.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

### Position

Ready for another riddle?

How could you make the chart below? Hint: given what you know now, you can't. So don't spend _too_ long trying.

```{r echo = FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

This plot displays the same information as the stacked bar chart above. Both charts show 40 color coded bars. Each bar represents a combination of `cut` and `clarity`. 

However, the position of the bars within the two charts differ. In the stacked bar chart, `ggplot2` stacked bars with the same `cut` on top of one another. In the second plot, `ggplot2` placed bars with the same cut beside each other.

You can control this behavior by adding a _position adjustment_ to your call. A position adjustment tells `ggplot2` what to do when two or more objects overlap.

To set a position adjustment, set the `position` argument of your geom function to one of `"identity"`, `"stack"`, `"dodge"`, `"fill"`, or `"jitter"`.

#### Position = "identity"

For many geoms, the default position value is "identity". When `position = "identity"`, `ggplot2` will place each object exactly where it falls in the context of the graph. 

This would make little sense for our bar chart. Each bar would start at `y = 0` and be placed directly above the `cut` value that it describes. Since there are seven bars for each `cut` value, many bars will overlap. The plot will look suspiciously like a stacked bar chart, but the stacked heights will be inaccurate, as each bar actually extends to `y = 0`.

to see how such a graph would appear, set `position = "identity"`.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "identity") +
  ggtitle('Position = "identity"')
```

#### Position = "stack"

To avoid confusion, `ggplot2` uses a default "stack" position adjustment for bar charts. When `position = "stack"` `ggplot2` places overlapping objects directly _above_ one another.

Here each bar begins exactly where the bar below it ends.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "stack") +
  ggtitle('Position = "stack"')
```

#### Position = "dodge"

When `position = "dodge"`, `ggplot2` places overlapping objects directly _beside_ one another. This is how I created the graph at the start of the section.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge") +
  ggtitle('Position = "dodge"')
```

#### Position = "fill"

When `position = "fill"`, `ggplot2` uses all of the available space to display overlapping objects. Within that space, it scales each in proportion to the other objects. `position = "fill"` is the most unusual of the position adjustments, but it creates an easy way to compare relative frequencies across groups.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill") +
  ggtitle('Position = "fill"')
```


#### Position = "jitter"

The last type of position doesn't make sense for bar charts, but it is very useful for scatterplots. Recall our first scatterplot.

Why does the plot appear to only display 126 points? There are 234 observations in the data set. Also, why do the points appear to be arranged on a grid?

```{r echo = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

The points appear in a grid because the `hwy` and `displ` measurements were rounded to the nearest integer and tenths values. As a result, many points overlap each other because they've been rounded to the same values of `hwy` and `displ`. This also explains why our graph appears to contain only 126 points. 108 points are hidden on top of other points located at the same value.

This arrangement can cause problems because it makes it hard to see where the mass of the data is. Is there one special combination of `hwy` and `displ` that contains 109 values? Or are the data points more or less equally spread throughout the graph?

You can avoid this overplotting problem by setting the position adjustment to "jitter".  `position = "jitter"` adds a small amount of random noise to each point, as we see above. This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

But isn't this, you know, bad? It *is* true that jittering your data will make it less accurate at the local level, but jittering may make your data _more_ accurate at the global level. By jittering your data, you can see where the mass of your data falls on an overplotted grid. Occasionally, jittering will reveal a pattern that was hidden within the grid.

`position = "jitter"` is shorthand for `position = position_jitter()`. This is true for the other values of position as well (e.g, `position_identity()`, `position_dodge()`, `position_fill()`, and `position_stack()`. The expanded syntax lets you specify details of the adjustment process, and also provides a way to open a help page for each process (which you will need to do if you wish to learn more).

```{r eval=FALSE}
?position_jitter
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), 
    position = position_jitter(width = 0.03, height = 0.3))
```

### Stats

How does `ggplot2` know where to place the line in our smooth plot?

```{r echo = FALSE, message = FALSE, fig.show='hold', fig.width=4, fig.height=4}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

The y values of the line do not appear in our data set, nor did we give the y values to `ggplot2`. `ggplot2` calculated they y values by applying an algorithm to the data. In this case, `ggplot2` applied a smoothing algorithm to the data.

Many types of graphs plot information that does not appear in the raw data. To do this, the graph first applies an algorithm to the raw data and then plots the results. For example, a boxplot calculates the first, second, and third quartiles of a data set and then plots those summary statistics (among others). A histogram bins the raw data and then counts how many points fall into each bin. It plots those counts on the y axis.

`ggplot2` calls these algorithms _stats_, which is short for statistical transformation. Stats are handled automatically in `ggplot2`. Not every geom uses a stat; but when one does, `ggplot2` will apply the stat in the background. 

You can fine tune how a geom implements a stat by passing the geom parameters for the stat to use. To discover which stat a geom uses, visit the geom's help page. 

For example, the `?geom_smooth` help page shows that `geom_smooth()` uses the `stat_smooth()` stat by default. If you then open the `?stat_smooth` help page, you will see that `stat_smooth()` takes the arguments `method` and `se` among others. With `ggplot2`, you can supply arguments to the stat called by a geom, by passing the arguments as parameters to the geom.

***

In general practice, you do not need to worry much about stats. Usually one geom will be closely associated with one stat, and `ggplot2` will implement the stat by default. However, stats are an integral part of the `ggplot2` package that you are welcome to modify. To learn more about `ggplot2`'s stat system, see [ggplot2: Elegant Graphics for Data Analysis](http://www.amazon.com/dp/0387981403/ref=cm_sw_su_dp?tag=ggplot2-20).

### Parameters

How do these two plots differ?

```{r echo = FALSE, message = FALSE, fig.show='hold', fig.width=4, fig.height=4}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth(method = lm)
```

Each overlays a smooth geom on a points geom, but each displays a different "type" of smooth line. In the first graph, `ggplot2` draws the result of a loess algorithm. In the second plot, `ggplot2` draws the result of a linear regression.

You can customize the output of `geom_smooth()` with its `method` argument. Set `method` to the name of a model function in R. `geom_smooth()` will display the result of modelling y on x with the function. In the graph above, we set `method = lm` to create the regression line. `lm()` is the R function that builds linear models.

```{r eval=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth(method = lm)
```

`method` is a _parameter_ of the `geom_smooth()` function, a piece of information that `ggplot2` uses to build the geom. If you do not set the `method` parameter, `ggplot2` defaults to a loess model or a general additive model depending on how many points appear in the graph.

`se` is another parameter of `geom_smooth()`. You can set the `se` parameter of `geom_smooth()` to `FALSE` to prevent `ggplot2` from drawing the standard error band that appears around the smooth line, i.e.

```{r }
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() +
  geom_smooth(method = lm, se = FALSE)
```

Parameters are different than mappings because you do not set a parameter to a variable in the data set. `ggplot2` uses the value of a parameter directly. In contrast, to use a mapping, `ggplot2` must create a system of equivalencies between values of a variable and levels of an aesthetic.

##### Aesthetics as parameters

The distinction between parameters and mappings makes it easy to customize your graphs. Suppose you want to make a graph like the one below. How would you do it?

```{r echo = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(color = "blue")
```

If you add `color = "blue"` to the mappings argument, you will get an unexpected result.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```

`ggplot2` treats `color = "blue"` as a mapping. It assumes that "blue" is a value in the data space. It uses R's recycling rules to assign the single value "blue" to each row of data. Then it creates a mapping from the value "blue" in the data space to the pinkish color that we see in the visual space. It even creates a legend to let you know that the color pink represents the value "blue." The choice of pink is a coincidence; `ggplot2` defaults to pink whenever a single discrete value is mapped to the color aesthetic.

This is not what we want. We want to set the color to blue. In short, we want to treat the color of the points like a parameter and set it directly.

To set an aesthetic as if it were a parameter, set it _outside_ of the `mapping` argument. This will place it outside of the `aes()` function as well.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

`ggplot2` will treat assignments that appear in the `aes()` call of the mapping argument as mappings. It will treat assignments that appear outside of the mappign argument as parameters.

As with aesthetics, different geoms respond to different parameters. How do you know which parameters to use with a geom? You can always treat a geom's aesthetics as parameters. You can also spot additional parameters by identifying a geom's stat.

### Coordinate systems

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut)) + 
  coord_flip()
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut)) + 
  coord_polar()
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = factor(1), fill = cut), width = 1) + 
  coord_polar(theta = "y")
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter") + 
  coord_cartesian(xlim = c(1, 5), ylim = c(25, 45))
```

## The Grammar of Graphics

### Layers

## Visualizing Distributions
### Discrete distributions
#### Bar Charts
### Continuous distributions
#### Histograms
#### Dotplots
#### Freqpoly
#### Density
#### Boxplots
### Bivariate Distributions
#### bin2d
#### hex
#### density2d
#### rug

## Visualizing Relationships
### Discrete x, discrete y
#### Jitter
### Discrete x, continuous y
#### Bar Charts
#### Boxplots
#### Dotplots
#### Violin plots
#### crossbar
#### errorbar
#### linerange
#### point range
### Continuous x, continuous y
#### Points
#### Text
#### Jitter
#### Smooth
#### Quantile
### Functions
#### line
#### area
#### step
### Discrete x, discrete y, continuous z
#### raster
#### tile
### Continuous x, continuous y, continuous z
#### contour

## Maps

## Customizing plots
### Titles
### Guides
### Scales
#### Color
#### Size
#### Shape
### Themes


