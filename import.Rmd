# Data import

## Introduction

Working with existing data is a great way to learn the tools, but you can't apply the tools to your own data unless you can get it into R. In this chapter, we'll focus on the readr package for reading plain-text rectangular files from disk. This only scratches the surface of the ways you can load data into R, but it's the common way to get data, and many of the principles will translate to the other forms of data import.

### Prerequisites

In this chapter, you'll learn how to load flat files in R with the readr package:

```{r setup}
library(readr)
```

## Basics

Most of readr's functions are concerned with turning flat files into data frames:

* `read_csv()` reads comma delimited files, `read_csv2()` reads semi-colon
  separated files (common in countries where `,` is used as the decimal place),
  `read_tsv()` reads tab delimited files, and `read_delim()` reads in files
  with any delimiter.

* `read_fwf()` reads fixed width files. You can specify fields either by their
  widths with `fwf_widths()` or their position with `fwf_positions()`.
  `read_table()` reads a common variation of fixed width files where columns
  are separated by white space.

* `read_log()` reads Apache style logs. (But also check out
  [webreadr](https://github.com/Ironholds/webreadr) which is built on top
  of `read_log()`, but provides many more helpful tools.)

These functions all have similar syntax: once you've mastered one, you can use the others with ease. For the rest of this chapter we'll focus on `read_csv()`. If you understand how to use this function, it will be straightforward to apply your knowledge to all the other functions in readr.

The first argument to `read_csv()` is the most important: it's the path to the file to read.

```{r}
heights <- read_csv("data/heights.csv")
```

You'll notice when you run `read_csv()` it prints how it has read each column. We'll come back to that in a little bit.

Readr can automatically decompress files ending in `.zip`, `.gz`, `.bz2`, and `.xz`. 

You can also supply an inline csv file. This is useful for experimenting and creating reproducible examples:

```{r}
read_csv("a,b,c
1,2,3
4,5,6")
```

Notice that `read_csv()` uses the first line of the data for column headings. This is a very common convention. There are two cases where you might want tweak this behaviour:

1.  Sometimes there are a few lines of metadata at the top of the file. You can
    use `skip = n` to skip the first `n` lines; or use `comment = "#"` to drop
    all lines that start with a comment character.
    
    ```{r}
    read_csv("The first line of metadata
      The second line of metadata
      x,y,z
      1,2,3", skip = 2)
    
    read_csv("# A comment I want to skip
      x,y,z
      1,2,3", comment = "#")
    ```
    
1.  The data might not have column names. You can use `col_names = FALSE` to
    tell `read_csv()` not to treat the first row as headings, and instead
    label them sequentially from `X1` to `Xn`:
    
    ```{r}
    read_csv("1,2,3\n4,5,6", col_names = FALSE)
    ```
    
    Alternatively you can pass `col_names` a character vector which will be
    used as the column names:
    
    ```{r}
    read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
    ```

This is all you need to know to read ~50% of csv files that you'll encounter in practice. To read in the rest, you'll need to learn more about how readr parses each individual column, turning a character vector into the most appropriate type.

### Compared to base R

If you've used R before, you might wonder why we're not using `read.csv()`. There are a few good reasons to favour readr functions over the base equivalents:

* They are typically much faster (~10x) than their base equivalents.
  Long running jobs also have a progress bar, so you can see what's
  happening. If you're looking for raw speed, try `data.table::fread()`,
  it doesn't fit so tidily into the tidyverse, but it can be quite a bit 
  faster than readr.

* They produce tibbles, and they don't convert character vectors to factors,
  produce row names, or munge the column names.

* They are more reproducible. Base R functions inherit some behaviour from
  your operation system, so code that works on your computer might not
  work on another computer.

### Exericses

1.  What function would you use to read a function that where fields were
    separated with with "|"?
   
1.  Apart from `file`, `skip`, and `comment`, what other arguments do
    `read_csv()` and `read_tsv()` have in common?
    
1.  Some times strings in a csv file contain commas. To prevent them from
    causing problems they need to be surrounded by a quoting character, like
    `"` or `'`. By convention, `read_csv()` assumes that the quoting
    character will be `"`, and if you want to change it you'll need to
    use `read_delim()` instead. What arguments do you need to specify
    to read the following text into a data frame?
    
    ```{r}
    "x,y\n1,'a,b'"
    ```

## Parsing a vector

Before we get into the details of how readr reads files from disk, we're going to take a little detour to talk about the `parse_*()` functions. These functions all take a character vector and return something more specialised like logical, integer, or date:

```{r}
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))
```

These functions are useful in their own right, but are also an important building block for readr. Once you've learned how the individual parsers work in this section, we'll circle back and see how they fit together to parse a complete file in the next section.

Like all functions in the tidyverse, the `parse_*()` functions are uniform: the first argument is a character vector to parse, and the `na` argument specifies which strings should be treated as missing.

```{r}
parse_integer(c("1", "231", ".", "456"), na = ".")
```

If parsing fails, you'll get a warning:

```{r}
x <- parse_integer(c("123", "345", "abc", "123.45"))
```

And the failures will be missing in the output:

```{r}
x
```

To get more details about the problems, use `problems()`, which returns a tibble. That's useful if you have many parsing failures because you can use dplyr to figure out the common patterns.

```{r}
problems(x)
```

Using parsers is mostly a matter of understanding what's avaialble and how they deal with different types of input. There are eight particularly important parsers:

1.  `parse_logical()` and `parse_integer()` parse logicals and integers
    respectively. There's basically nothing that can go wrong with them
    so I won't describe them here further.
    
1.  `parse_double()` is a strict numeric parser, and `parse_number()` 
    is a flexible numeric parser. These are more complicated than you might
    expect because different parts of the world write numbers in different
    ways.
    
1.  `parse_character()` seems so simple that it shouldn't be necessary. But
    one complication makes it quite important: character encodings.

1.  `parse_datetime()`, `parse_date()`, and `parse_time()` allow you to
    parse various date & time specifications. These are the most complicated
    because there are so many different ways of writing dates.

The following sections describe the parsers in more detail.

### Numbers

It seems like it should be straightforward to parse a number, but three factors make it tricky:

1. People write numbers differently in different parts of the world.
   Some countries use `.` in between the integer and fractional parts of
   a real number, while others uses `,`.
   
1. Numbers are often surrounded by other characters that provide some
   context, like "$1000" or "10%".

1. Numbers often contain "grouping" characters to make them easier to read, 
   like "1,000,000", and the characters are differ around the world.

To address the first problem, readr has the notion of a "locale", an object that specifies parsing options that differ around the world. For parsing numbers, the most important option is what character you use for the decimal mark:

```{r}
parse_double("1.23")
parse_double("1,23", locale = locale(decimal_mark = ","))
```

The default locale in readr is US-centric, because R generally is US-centric (i.e. the documentation of base R is written in American English). An alternative approach would be to try and guess the defaults from your operating system. This is hard to do well, but more importantly makes your code fragile: it might work on your computer, but might fail when you email it to a colleague in another country.

`parse_number()` addresses problem two: it ignores non-numeric characters before and after the number. This is particularly useful for currencies and percentages, but also works to extract numbers embedded in text.

```{r}
parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45")
```

The final problem is addressed with the combination of `parse_number()` the locale: `parse_number()` will also ignore the "grouping mark" used to separate numbers:

```{r}
parse_number("$100,000,000")
parse_number("123.456,789", locale = locale(grouping_mark = "."))
```

### Character

It seems like `parse_character()` should be really simple - it could just return its input. Unfortunately life isn't so simple, as there are multiple ways to represent the same string. To understand what's going on, we need to dive into the details of how computers represent strings. In R, we can get at the underlying binary representation of a string using `charToRaw()`:

```{r}
charToRaw("Hadley")
```

Each hexadecimal number represents a byte of information: `48` is H, `61` is a, and so on. This encoding, from hexadecimal number to character is called ASCII. ASCII does a great job of representing English characters. 

Unfortunately you can only represent a maximum of 255 values with a single byte of information, and there are many more characters when you look across languages. That means to represent a character in other languages you need to use multiple bytes of information. The way multiple bytes are used to encode a character is called the "encoding".

In the early days of computing there were many different ways of representing non-English characters which caused a lot of confusion. Fortunately, today there is one standard that is supported almost everywhere: UTF-8. UTF-8 can encode just about every character used by human's today, as well as many extra symbols (like emoji!).

readr uses UTF-8 everywhere: it assumes your data is UTF-8 encoded when you read it, and always uses it when writing. This is a good default, but will fail for data produced by older systems that don't understand UTF-8.  Unfortunately handling 

However, you may be attempting to read data that is produced by a system that doesn't understand UTF-8. You can tell you need to do this because when you print the data in R it looks weird. Sometimes you might get complete gibberish, or sometimes just one or two characters might be messed up.

```{r}
x1 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"
x2 <- "El Ni\xf1o was particularly bad this year"

x1
x2
```

To fix the problem you need to specify the encoding in `parse_character()`:

```{r}
parse_character(x1, locale = locale(encoding = "Shift-JIS"))
parse_character(x2, locale = locale(encoding = "Latin1"))
```

How do you find the correct encoding? If you're lucky, it'll be included somewhere in the data documentation. But that rarely happens so readr provides  `guess_encoding()` to help you figure it out. It's not foolproof, and it works better when you have lots of text, but it's a reasonable place to start. Even then you may need to try a couple of different encodings before you get the right once.

```{r}
guess_encoding(charToRaw(x1))
guess_encoding(charToRaw(x2))
```

The first argument to `guess_encoding()` can either be a path to a file, or, as in this case, a raw vector (useful if the strings are already in R).

Encodings are a rich and complex topic, and I've only scratched the surface here. We'll come back to encodings again in [[Encoding]], but if you'd like to learn more I'd recommend reading the detailed explanation at <http://kunststube.net/encoding/>.

### Dates, date times, and times

You pick between three parsers depending on whether you want a date (the number of days since 1970-01-01), a date time (the number of seconds since midnight 1970-01-01), or a time (i.e. the number of seconds since midnight). The defaults read:

*   `parse_datetime()` expects an ISO8601 date time. ISO8691 is an
    international standard in which the components of a date are
    organised from biggest to smallest: year, month, day, hour, minute, 
    second:
    
    ```{r}
    parse_datetime("2010-10-01T2010")
    # If time is omitted, it will be set to midnight
    parse_datetime("20101010")
    ```
    
    This is the most important date/time standard, and if you work with
    dates and times frequently, I recommend reading
    <https://en.wikipedia.org/wiki/ISO_8601>
    
*   `parse_date()` expects a year, an optional separator, a month, 
    an optional separator, and then a day:
    
    ```{r}
    parse_date("2010-10-01")
    ```

*   `parse_time()` expects an hour, an optional colon, a minute, 
    an optional colon, optional seconds, and optional am/pm specifier:
  
    ```{r}
    library(hms)
    parse_time("20:10:01")
    ```
    
    Base R doesn't have a great built in class for time data, so we use 
    the one provided in the hms package.

If these defaults don't work for your data you can supply your own datetime formats, built up of the following pieces:

Year
:  `%Y` (4 digits). 
: `%y` (2 digits); 00-69 -> 2000-2069,  70-99 -> 1970-1999.

Month
: `%m` (2 digits)
: `%b` (abbreviated name, like "Jan")
: `%B` (full name, "January").

Day

: `%d` (2 digits)
: `%e` (optional leading space)

Time

: `%H` 0-24 hour.
: `%I` 1-12, must be used with `%p`.
: `%p` AM/PM indicator.
: `%M` minutes.
: `%S` integer seconds.
: `%OS` real seconds. 
: `%Z` Time zone (as name, e.g. `America/Chicago`). Beware abbreviations:
  if you're American, note that "EST" is a Canadian time zone that does not
  have daylight savings time. It is \emph{not} Eastern StandardTime!
: `%z` (as offset from UTC, e.g. `+0800`). 

Non-digits:

: `%.` skips one non-digit character
: `%*` skips any number of non-digits.

The best way to figure out the correct string is to create a few examples in a character vector, and test with one of the parsing functions. For example:

```{r}
parse_date("01/02/15", "%m/%d/%y")
parse_date("01/02/15", "%d/%m/%y")
parse_date("01/02/15", "%y/%m/%d")
```

If you're using `%b` or `%B` with non-English month names, you'll need to set the  `lang` argument to `locale()`. See the list of built-in languages in `date_names_langs()`, or if your language is not already included, create your own with `date_names()`.

```{r}
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
```

### Exercises

1.  What are the most important arguments to `locale()`?  If you live
    outside the US, create a new locale object that encapsulates the
    settings for the types of file you read most commonly.
    
1.  What's the difference between `read_csv()` and `read_csv2()`?
    
1.  I didn't discuss the `date_format` and `time_format` options to
    `locale()`. What do they do? Construct an example that shows when they
    might be useful.
    
1.  What are the most common encodings used in Europe? What are the
    most common encodings used in Asia?

1.  Generate the correct format string to parse each of the following 
    dates and times:
    
    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- "August 19 (2015)"
    d5 <- "12/30/14" # Dec 12, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Parsing a file

Now that you've learned how to parse an individual vector, it's time to turn back and explore how readr parses a file. There are two new things that you'll learn about in this section:

1. How readr automatically guesses the type of a column
1. How to override the default specification

### Strategy

Readr uses a heuristic to figure out the type of each columns: it reads the first 1000 rows and uses some (moderately conservative) heuristics to figure out the type of each column. 

You can emulate this process with a character vector using `guess_parser()`, which returns readr's best guess, and `parse_guess()` which uses that guess to parse the column:

```{r}
guess_parser("2010-10-01")
guess_parser("15:01")
guess_parser(c("TRUE", "FALSE", "FALSE", "TRUE"))
guess_parser(c("1", "5", "9"))
```

The basic rules try each of these in turn, working from strictest to most flexible:

* logical: contains only "F", "T", "FALSE", or "TRUE"
* integer: contains only numeric characters (and `-`)
* double: contains only valid doubles (including numbers like `4.5e-5`)
* number: contains valid doubles with the grouping mark inside
* time: matches the default time format
* date: matches the default date format
* date time: any ISO8601 date
* character: everything else

(Note that the details will change a little from version to version as we tweak the guesses to provide the best balance between false positives and false negatives)

### Problems

These defaults don't always work for larger files. There are two basic problems:

1.  The first thousand rows might be a special case, and readr guesses
    a type that is too specific for the general case. For example, you
    might have column of doubles that only contains integers in the first
    1000 rows. 

1.  The column might contain a lot of missing values. If the first 1000
    rows contains on `NA`s, readr will guess that it's a character 
    column, whereas you probably want to parse it as something more
    specific.

readr contains a challenging csv that illustrates both of these problems:

```{r}
challenge <- read_csv(readr_example("challenge.csv"))
```

Note the two outputs: you see the column specification that readr used, and you can see all the problems. It's always a good idea to explicitly pull out the `problems()` so you can explore them in more depth:

```{r}
problems(challenge)
```

A good strategy is to work column by column until there are no problems remaining. Here we can see that there are a lot of parsing problems with the `x` column - there are trailing characters after the integer value. That suggests we need to use a double vector instead.

Start by copying and pasting the column specification into your original call:

```{r, eval = FALSE}
challenge <- read_csv(
  readr_example("challenge.csv"), 
  col_types = cols(
    x = col_integer(),
    y = col_character()
  )
)
```

Then you can tweak the type of the `x` column:

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"), 
  col_types = cols(
    x = col_double(),
    y = col_character()
  )
)
```

That fixes the first problem, but if we look at the last few rows, you'll see that they're dates stored in a character vector:

```{r}
tail(challenge)
```

You can fix that by specifying that `y` is date column:

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"), 
  col_types = cols(
    x = col_double(),
    y = col_date()
  )
)
tail(challenge)
```

Every `parse_xyz()` function has a corresponding `col_xyz()` function. You use `parse_xyz()` when the data is in a character vector in R already; you use `col_xyz()` when you want to tell readr how to load the data.

I highly recommend building up a complete column specification using the print out provided by readr. This ensures that you have a consistent reproducible way of reading the file - if you rely on the default guesses, if your data changes readr will continue to read it in. If you want to be really strict, use `stop_for_problems()`: that will throw an error if there are any parsing problems.

### Other strategies:

*   In this case we just got unlucky, and if we'd looked at just
    a few more rows, we could have correctly parsed in one shot:
   
    ```{r}
    challenge2 <- read_csv(readr_example("challenge.csv"), guess_max = 1001)
    challenge2
    ```

*   Sometimes it's easier to diagnose problems if you just read in all
    the columns as character vectors:
   
    ```{r}
    challenge2 <- read_csv(readr_example("challenge.csv"), 
      col_types = cols(.default = col_character())
    )
    ```
    
    This is particularly useful in conjunction with `type_convert()`,
    which applies the parsing heuristics to the character columns in a data
    frame. It's useful if you've loaded data "by hand", and now want to
    convert character columns to the appropriate type:

    ```{r}
    df <- tibble::tibble(
       x = c("1", "2", "3"), 
       y = c("1.21", "2.32", "4.56")
    )
    df
    # Note the column types
    type_convert(df)
    ```
    
*   If you're reading a very large file, you might want to set `n_max` to
    10,000 or 100,000. That will speed up iterations while you're finding
    common problems

*   If you're having major parsing problems, sometimes it's easier
    to just read into a character vector of lines with `read_lines()`,
    or even a character vector of length 1 with `read_file()`. Then you
    can use the string parsing skills you'll learn later to parse
    more exotic formats.

## Writing to a file

readr also comes with two useful functions for writing data back to disk: `write_csv()` and `write_tsv()`. They:

* Are faster than the base R equvalents.

* Never write rownames, and quote only when needed. 

* Always encode strings in UTF-8.  If you want to export a csv file to 
  Excel, use `write_excel_csv()` - this writes a special character 
  (a "byte order mark") at the start of the file which forces Excel 
  to use UTF-8.
  
* Save dates and datetimes in ISO8601 format so they are easily
  parsed elsewhere.

The most important arguments are `x` (the data frame to save), and `path` (the location to save it). You can also specify how missing values are written with `na`, and if you want to `append` to an existing file.

```{r, eval = FALSE}
write_csv(challenge, "challenge.csv")
```

Note that the type information is lost when you save to csv:

```{r, warning = FALSE}
challenge
write_csv(challenge, "challenge-2.csv")
read_csv("challenge-2.csv")
```

This makes csvs a little unreliable for caching interim results - you need to recreate the column specification every time you load in.  There are two alternatives:

1.  `write_rds()` and `read_rds()` are wrappers around the base functions
    `readRDS()` and `saveRDS()`. These store data in R's custom binary
    format:
    
    ```{r}
    write_rds(challenge, "challenge.rds")
    read_rds("challenge.rds")
    ```
  
1.  The feather package implements a fast binary file format that can
    be shared across programming languages:
    
    ```{r}
    library(feather)
    write_feather(challenge, "challenge.feather")
    read_feather("challenge.feather")
    ```

feather tends to be faster than rds and is usable outside of R. `rds` supports list-columns (which you'll learn about in [[Many models]]), which feather does not yet.

```{r, include = FALSE}
file.remove("challenge-2.csv")
file.remove("challenge.rds")
file.remove("challenge.feather")
```

## Other types of data

We have worked on a number of packages to make importing data into R as easy as possible. These packages are certainly not perfect, but they are the best place to start because they behave as similar as possible to readr. 

Two packages helper

* haven reads files from other SPSS, Stata, and SAS files.

* readxl reads excel files (both `.xls` and `.xlsx`).

There are two common forms of hierarchical data: XML and json. We recommend using xml2 and jsonlite respectively. These packages are performant, safe, and (relatively) easy to use. To work with these effectively in R, you'll need to x

If your data lives in a database, you'll need to use the DBI package. DBI provides a common interface that works with many different types of database. R's support is particularly good for open source databases (e.g. RPostgres, RMySQL, RSQLite, MonetDBLite).
